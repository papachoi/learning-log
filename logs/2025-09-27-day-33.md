# Day 33 — Hands-on FHE with Pyfhel (BFV)

## ✅ Shipped
- Ran a minimal Pyfhel example that performs **addition** and **multiplication** on **encrypted vectors** using the **BFV** scheme with batching.

## 🧪 What I tried (essentials)
1) **Context & keys**
- Scheme: BFV (good for exact integer arithmetic).
- Generate context with batching enabled; generate secret/public keys.

2) **Encode → Encrypt**
- Encode int vectors (e.g., `[1..8]`) and encrypt them to ciphertexts.

3) **Compute on ciphertexts**
- Homomorphic **addition** and **multiplication** on encrypted vectors.

4) **Decrypt → Decode**
- Recover plaintext vectors and verify results match plaintext math.

## 🧾 Expected output (concept)
X = [1 2 3 4 5 6 7 8]
Y = [1 2 3 4 5 6 7 8]

X + Y = [ 2 4 6 8 10 12 14 16]
X * Y = [ 1 4 9 16 25 36 49 64]

markdown
Copy code

## ⚙️ Notes & gotchas
- **Pyfhel API differs by version.** If `encode_int` / `encrypt` don’t exist in your build, the common alternatives are:
  - `encryptBatch(list_of_ints)` / `decryptBatch(cipher)`
  - Or `encodeBatch(...)` + `encryptPtxt(...)` / `decrypt(...)` + `decodeBatch(...)`
- **Backends** (`set_backend('openfhe')`) may require extra system deps. If it errors, skip the backend line and use defaults first.
- For BFV, typical safe starters are `p=65537`, `m=8192` (or similar power-of-two), `sec≈128`, with batching enabled.

## 📌 Key takeaways
- FHE lets me do vectorized add/mul **without ever decrypting** in the compute step.
- BFV preserves exact integers; CKKS is for approximate real numbers.
- Batching = pack many integers into one ciphertext to speed things up.

## 🧭 Next
- Benchmark timing with different `m`/poly modulus degrees.
- Try **CKKS** for real-valued vectors and compare precision vs speed.
- Save results to a CSV and chart latency vs parameters for the log.
